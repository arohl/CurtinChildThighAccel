'''Routines for plotting accelerometer data and results of activity recognition.'''
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors

import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots

# x, y and z accelerometer colors
ACCELEROMETER_COLORS = ['blue', 'red', 'green']

# Number of colors per base color
N_COLORS = 6

# colors are indexes into colormap that is generated by build_colormap_from_bases
MOTUS_LABEL_COLORS = {
    'Lie': 3,
    'Sit': 7,
    'Stand': 13,
    'Other': 31,
    'Walk': 15,
    'Run': 18,
    'Stairs': 26,
    'NotRecording': 33,
}

CURTIN_LABEL_COLORS = {
    'Lying Prone': 2,
    'Lying Supine': 3,
    'Lying Side': 4,
    'Sitting': 7,
    'Low kneeling': 8,
    'Half kneeling': 9,
    'High kneeling': 10,
    'All 4s': 12,
    'Standing': 13,
    'Throwing and catching': 14,
    'Walking': 15,
    'Walking upstairs': 16,
    'Walking downstairs': 17,
    'Running': 18,
    'Skipping': 19,
    'Jumping': 20,
    'Running upstairs': 26,
    'Running downstairs': 27,
    'Handstand': 28,
    'Cartwheel': 29,
    'Transition': 30,
    'Other': 31,
    'Uncodable': 32,
    'Unsure': 33,
    'NA': 34
}

def build_colormap_from_bases(n_colors=5, base_colormaps=None):
    """Builds a colormap by extracting a specified number of colors from a list of base color maps, avoiding overly light or dark colors.

    Args:
    	n_colors (int, optional): number of colors to be extracted from each base colormap. Defaults to 5.
      	base_colormaps (list of str, optional): list of the names of base colormaps from which to extract colors. Defaults to ['Greens', 'Oranges', 'Blues', 'Purples', 'Reds', 'Greys'].

    Returns:
    	matplotlib.colors.ListedColormap: the generated colormap
    """

    if base_colormaps is None:
        base_colormaps = ['Blues', 'Greens', 'Purples', 'Oranges', 'Reds', 'Greys']

    colors = np.concatenate([plt.get_cmap(name)(np.linspace(0.25, 0.75, n_colors)) for name in base_colormaps])

    return mcolors.ListedColormap(colors)

COLORMAP = build_colormap_from_bases(n_colors=N_COLORS)

def plot_colormap(colormap):
    """
    Plots a colormap as a gradient image.

    Args:
        colormap (matplotlib.colors.Colormap): The colormap to plot.
    """

    gradient = np.linspace(0, 1, 256)
    gradient = np.vstack((gradient, gradient))

    plt.figure(figsize=(10.0,1.5))
    plt.imshow(gradient, aspect='auto', cmap=colormap)

    # Adjust the x-ticks to be at the midpoint of each color in the colormap
    tick_positions = np.linspace(0, 256, colormap.N, endpoint=False)
    tick_positions += (256 / colormap.N) / 2  # shift by half the width of each color

    plt.xticks(tick_positions, np.arange(colormap.N), rotation='vertical')
    plt.yticks([])
    plt.show()

def plot_raw_accelerometer_data(data, label_colors, plot_mag=False, dimensions=None, no_whitespace=False, legend=True, y_axis_range=None):
    """Plots the raw accelerometer data with the activities overlaid as shaded rectangles.

    Args:
        data (pandas.DataFrame): A dataframe indexed by time with 'x', 'y', 'z', and 'annotation' columns present.
        label_colors (dict): A dictionary mapping activity names to colors.
        plot_mag (bool, optional): If True, plots the magnitude of acceleration, rather than the individual components. Defaults to False.
        dimensions (tuple, optional): Dimensions of the plot in pixels (width, height). If None, Plotly will autosize the plot. Defaults to None.
        no_whitespace (bool, optional): If True, removes all whitespace. Defaults to False.
        legend (bool, optional): If True, adds a legend to the plot. Defaults to True.
        y_axis_range (tuple, optional): The range of the axes (ymin, ymax). If None, Plotly will autoscale the y-axis. Defaults to None.

    Returns:
        plotly.graph_objs.Figure: A plotly figure of the accelerometer data.
    """

    required_columns = {'x', 'y', 'z', 'annotation'}
    if not required_columns.issubset(data.columns):
        missing_columns = required_columns.difference(data.columns)
        raise ValueError(f'Dataframe missing columns: {", ".join(missing_columns)}')

    if not isinstance(data.index, pd.DatetimeIndex):
        raise ValueError('The dataframe index should be a DatetimeIndex')

    if plot_mag:
        # add magnitude column
        data['mag'] = np.sqrt(data['x']**2 + data['y']**2 + data['z']**2)

    fig = go.Figure()

    # Create a new column 'group' that is incremented whenever 'annotation' changes
    # Note have put first value as default for NaN so first comparison is False
    data['group'] = (data['annotation'] != data['annotation'].shift().fillna(data['annotation'].iloc[0])).cumsum()

    # For each group find indices of consecutive rows
    indices = [list(group) for group in data.groupby('group').groups.values()]

    # Extend each group by one index so each group runs into the next
    for i in range(len(indices) - 1):
        indices[i].append(indices[i + 1][0])

    # For each group, add a rectangle to the plot colored by the activity
    for index_group in indices:
        subgroup = data.loc[index_group]  # Get the data of the current group
        color = f'rgba{COLORMAP(label_colors[subgroup["annotation"].iloc[0]])}'

        fig.add_shape(
            type='rect',
            xref='x',
            yref='paper',
            x0=subgroup.index.min(),
            x1=subgroup.index.max(),
            y0=0,
            y1=1,
            fillcolor=color,
            opacity=1.0,
            layer='below',
            line_width=0
        )

    if plot_mag:
        fig.add_scatter(
            x=data.index,
            y=data['mag'],
            mode='lines',
            line=dict(width=1.0, color='black'),
            hovertemplate=
#                    '<b>Time</b>: %{x|%H:%M:%S}<br>' +
                '<br><b>Activity</b>: %{text}' +
                '<br><b>Magnitude</b>: %{y}<br><extra></extra>',
            text=data['annotation'],
            showlegend=False
        )
    else:
        for i, trace in enumerate(['x', 'y', 'z']):
            fig.add_scatter(
                x=data.index,
                y=data[trace],
                mode='lines',
                line=dict(width=1.0, color=ACCELEROMETER_COLORS[i]),
                hovertemplate=
#                    '<b>Time</b>: %{x|%H:%M:%S}<br>' +
                    '<b>Activity</b>: %{text}' +
                    f'<br><b>{trace}</b>: %{{y}}<br><extra></extra>',
                text=data['annotation'],
                showlegend=False
            )

    # Create a legend to match the activies plotted on the background
    if legend:
        for annotation, color_idx in label_colors.items():
            color = f'rgba{COLORMAP(color_idx / (COLORMAP.N - 1))}'
            fig.add_scatter(
                x=[None],
                y=[None],
                mode='lines',
                line=dict(color=color, width=8),
                name=str(annotation)
            )

    fig.update_layout(
        autosize=True if dimensions is None else False,
        width=dimensions[0] if dimensions else None,
        height=dimensions[1] if dimensions else None,
        yaxis=dict(fixedrange=True),
        hovermode='x',
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        margin=dict(
            l=0,  # left margin
            r=0,  # right margin
            b=0,  # bottom margin
            t=0,  # top margin
            pad=0  # padding
        ) if no_whitespace else None,
    )

    if y_axis_range:
        fig.update_yaxes(range=y_axis_range)

    # Drop the 'group' and 'mag' (if exists) columns so that the original dataframe remains unchanged
    data.drop('group', axis=1, inplace=True)
    if plot_mag:
        data.drop('mag', axis=1, inplace=True)

    return fig

def plot_multiple_raw_accelerometer_data(data, label_colors, plot_mag=False, same_activities=True, dimensions=None, no_whitespace=False, legend=True, y_axis_range=None):
    """Plots multiple raw accelerometer data with the activities overlaid as shaded rectangles.

    Args:
        data (dict of pandas.DataFrame): A dictionary of dataframes indexed by time with 'x', 'y', 'z', and 'annotation' columns present.
        label_colors (dict): A dictionary mapping activity names to colors.
        same_activities (bool, optional): Whether or not all plots have same activities. If they do prints only one legend. Defaults to True.
        plot_mag (bool, optional): If True, plots the magnitude of acceleration, rather than the individual components. Defaults to False.
        dimensions (tuple, optional): Dimensions of the plot in pixels (width, height). If None, plot will autosize. Defaults to None.
        no_whitespace (bool, optional): If True, removes all whitespace. Defaults to False.
        legend (bool, optional): If True, adds a legend to the plot. Defaults to True.
        y_axis_range (tuple, optional): The range of the axes (ymin, ymax). If None, Plotly will autoscale each y-axis independently. Defaults to None.

    Returns:
        plotly.graph_objs.Figure: A plotly figure of the accelerometer data.
    """

    height_per_subplot = 300
    required_columns = {'x', 'y', 'z', 'annotation'}

    # check to see if any of the dictionary entries are None and remove them
    data = {k: v for k, v in data.items() if v is not None} 

    fig = make_subplots(rows=len(data.keys()), cols=1, shared_xaxes=True, vertical_spacing=0.1, subplot_titles=list(data.keys()))
    width=dimensions[0] if dimensions else None
    height=dimensions[1] if dimensions else height_per_subplot*len(data.keys())
    fig.update_layout(height=height, width=width)

    for key_index, key in enumerate(data.keys()):

        if not required_columns.issubset(data[key].columns):
            missing_columns = required_columns.difference(data[key].columns)
            raise ValueError(f'Dataframe missing columns: {", ".join(missing_columns)}')

        if not isinstance(data[key].index, pd.DatetimeIndex):
            raise ValueError('The dataframe index should be a DatetimeIndex')

        if plot_mag:
            # add magnitude column
            data[key]['mag'] = np.sqrt(data[key]['x']**2 + data[key]['y']**2 + data[key]['z']**2)

        # Create a new column 'group' that is incremented whenever 'annotation' changes
        # Note have put first value as default for NaN so first comparison is False
        data[key]['group'] = (data[key]['annotation'] != data[key]['annotation'].shift().fillna(data[key]['annotation'].iloc[0])).cumsum()

        # For each group find indices of consecutive rows
        indices = [list(group) for group in data[key].groupby('group').groups.values()]

        # Extend each group by one index so each group runs into the next
        for i in range(len(indices) - 1):
            indices[i].append(indices[i + 1][0])

        # For each group, add a rectangle to the plot colored by the activity
        for index_group in indices:
            subgroup = data[key].loc[index_group]  # Get the data[key] of the current group
            color = f'rgba{COLORMAP(label_colors[subgroup["annotation"].iloc[0]])}'

            fig.add_shape(
                type='rect',
                xref='x',
                yref='paper',
                x0=subgroup.index.min(),
                x1=subgroup.index.max(),
                y0=y_axis_range[0],
                y1=y_axis_range[1],
                fillcolor=color,
                opacity=1.0,
                layer='below',
                line_width=0,
                row=key_index+1,
                col=1
            )

        if plot_mag:
            fig.add_scatter(
                x=data[key].index,
                y=data[key]['mag'],
                mode='lines',
                line=dict(width=1.0, color='black'),
                hovertemplate=
    #                    '<b>Time</b>: %{x|%H:%M:%S}<br>' +
                    '<br><b>Activity</b>: %{text}' +
                    '<br><b>Magnitude</b>: %{y}<br><extra></extra>',
                text=data[key]['annotation'],
                showlegend=False,
                row=key_index+1,
                col=1
            )
        else:
            for i, trace in enumerate(['x', 'y', 'z']):
                fig.add_scatter(
                    x=data[key].index,
                    y=data[key][trace],
                    mode='lines',
                    line=dict(width=1.0, color=ACCELEROMETER_COLORS[i]),
                    hovertemplate=
    #                    '<b>Time</b>: %{x|%H:%M:%S}<br>' +
                        '<b>Activity</b>: %{text}' +
                        f'<br><b>{trace}</b>: %{{y}}<br><extra></extra>',
                    text=data[key]['annotation'],
                    showlegend=False,
                    row=key_index+1,
                    col=1
                )

        # Create a legend to match the activies plotted on the background
        if legend:
            if not same_activities or key_index == 0:
                for annotation, color_idx in label_colors.items():
                    color = f'rgba{COLORMAP(color_idx / (COLORMAP.N - 1))}'
                    fig.add_scatter(
                        x=[None],
                        y=[None],
                        mode='lines',
                        line=dict(color=color, width=8),
                        name=str(annotation),
                        row=key_index+1,
                        col=1
                    )

        if y_axis_range:
            fig.update_yaxes(range=y_axis_range, row=key_index+1, col=1)

        # Drop the 'group' and 'mag' (if exists) columns so that the original dataframe remains unchanged
        data[key].drop('group', axis=1, inplace=True)
        if plot_mag:
            data[key].drop('mag', axis=1, inplace=True)

    fig.update_layout(
        yaxis=dict(fixedrange=True),
        hovermode='x',
        plot_bgcolor='rgba(0,0,0,0)',
        paper_bgcolor='rgba(0,0,0,0)',
        margin=dict(
            l=0,  # left margin
            r=0,  # right margin
            b=0,  # bottom margin
            t=0,  # top margin
            pad=0  # padding
        ) if no_whitespace else None,
    )

    return fig

def plot_scatter(X, Y, label_colors):
    """Create an interactive scatterplot of two principal components

    Args:
        X (array-like): A 2D array of shape (n_samples, 2) containing the principal components.
        Y (array-like): A 1D array of shape (n_samples,) containing the labels.
        label_colors (dict): A dictionary mapping activity names to colors.
    """

    df = pd.DataFrame(X, columns=['PC1', 'PC2'])
    df['label'] = Y

    discrete_colormap = {label: f'rgba{COLORMAP(label_colors[label])}' for label in df['label'].unique()}

    fig = px.scatter(df, x='PC1', y='PC2', color='label', color_discrete_map=discrete_colormap, opacity=1.0)
    fig.update_traces(marker={'size': 3})
    fig.update_layout(
        autosize=False,
        width=600,
        height=600,
        xaxis=dict(
            scaleanchor = 'y',
            scaleratio = 1,
            gridcolor='lightgrey',
            zerolinecolor='lightgrey'
        ),
        yaxis=dict(
            gridcolor='lightgrey',
            zerolinecolor='lightgrey'
        ),
        plot_bgcolor='white',
        paper_bgcolor='white'
    )
    fig.show()

def add_shapes(fig, time_starts, time_ends, activity_array, label_colors, y_extents, index):
    """
    Adds shaded rectangles representing activities to a provided plotly figure.

    Args:
        fig (plotly.graph_objs._figure.Figure): The figure to which the shapes will be added.
        time_starts (list of datetime.datetime): The start times of the activities.
        time_ends (list of datetime.datetime): The end times of the activities.
        activity_array (list of str): The labels of the activities.
        label_colors (dict): A dictionary mapping activity labels to colors.
        y_extents (list): The y-axis extents for the rectangles.
        index (int): The index of the subplot to which the shapes will be added.
    """
    for start, end, activity in zip(time_starts, time_ends, activity_array):
        shape = dict(
            type='rect',
            xref='x',
            yref='y',
            x0=start,
            y0=y_extents[0],
            x1=end,
            y1=y_extents[1],
            fillcolor=f'rgba{COLORMAP(label_colors[activity])}',
            opacity=1.0,
            layer='below',
            line_width=0,
        )
        fig.add_shape(shape, row=index+1, col=1)

def find_consecutive_activities(t, label, window_size):
    """
    Finds consecutive activities in the provided time series data.

    Args:
        t (pandas.core.series.Series): The time stamps for the label data.
        label (pandas.core.series.Series): The activity labels.
        window_size (int): The size of the windows in seconds.

    Returns:
        time_starts (list of datetime.datetime): The start times of the activities.
        time_ends (list of datetime.datetime): The end times of the activities.
        activity_array (list of str): The labels of the activities.
    """

    time_starts, time_ends, activity_array = [], [], []
    current_label = None
    last_time = None
    count = 0
    for time, activity in zip(t, label):
        # Calculate difference from the previous time point
        diff_time = (time - last_time).total_seconds() if last_time is not None else np.inf
        if activity != current_label or diff_time > window_size:
            if current_label is not None:    # Avoid adding to time_ends for the very first iteration
                time_ends.append(time_starts[-1] + pd.Timedelta(seconds=window_size * count))  # End time based on the last start time
            time_starts.append(time)
            activity_array.append(activity)
            current_label = activity
            count = 0
        last_time = time
        count += 1

    # End of the last activity period
    time_ends.append(last_time + pd.Timedelta(seconds=window_size))

    return time_starts, time_ends, activity_array

def add_traces(fig, time_starts, time_ends, activity_array, trace, t, index):
    """
    Adds traces representing activities to a provided plotly figure.

    Args:
        fig (plotly.graph_objs._figure.Figure): The figure to which the traces will be added.
        time_starts (list of datetime.datetime): The start times of the activities.
        time_ends (list of datetime.datetime): The end times of the activities.
        activity_array (list of str): The labels of the activities.
        trace (numpy.ndarray): The trace data.
        t (pandas.core.series.Series): The timestamps for the trace data.
        index (int): The index of the subplot to which the traces will be added.
    """
    if trace is None:
        return
    else:
        for i, (start, end, activity) in enumerate(zip(time_starts, time_ends, activity_array)):
            # Identify the segment of the trace data that falls within the current rectangle
            mask = (t >= start) & (t < end)
            trace_segment = trace[mask]
            t_segment = t[mask]

            # Check if the start time of next frame equals the end time of current
            if i + 1 < len(time_starts) and end == time_starts[i + 1]:
                # If so, find the value at start of next segment
                next_mask = (t >= time_starts[i + 1]) & (t < time_ends[i + 1])
                next_trace_segment = trace[next_mask]

                # If there's at least one value in the next segment, use its first value
                if len(next_trace_segment) > 0:
                    trace_segment = np.append(trace_segment, next_trace_segment[0])
            else:
                trace_segment = np.append(trace_segment, trace_segment[-1])

            t_segment = t_segment.append(pd.DatetimeIndex([end]))

            # Add trace for the identified segment
            fig.add_trace(go.Scatter(x=t_segment, y=trace_segment, mode='lines',
                                    name=str(activity),
                                    line=dict(color='black', width=1.0),
                                    marker=dict(size=3),
                                    showlegend=False), row=index+1, col=1)

def add_raw_traces(fig, time_starts, time_ends, activity_array, raw_trace, t, window_size, index):
    """
    Adds raw accelerometer traces to a provided plotly figure.

    Args:
        fig (plotly.graph_objs._figure.Figure): The figure to which the raw traces will be added.
        time_starts (list of datetime.datetime): The start times of the activities.
        time_ends (list of datetime.datetime): The end times of the activities.
        activity_array (list of str): The labels of the activities.
        raw_trace (numpy.ndarray): The trace data.
        t (pandas.core.series.Series): The timestamps for the trace data.
        window_size (int): Window size in seconds.
        index (int): The index of the subplot to which the traces will be added.
    """

    if raw_trace is None:
        return
    else:
        sample_rate = raw_trace.shape[1]/window_size
        for i, (start, end, activity) in enumerate(zip(time_starts, time_ends, activity_array)):
            # Identify the segment of the trace data that falls within the current rectangle
            mask = (t >= start) & (t < end)
            raw_segment = raw_trace[mask]
            trace_segment = raw_segment.reshape(-1, raw_segment.shape[-1])
            t_segment = start + pd.to_timedelta(np.arange(trace_segment.shape[0]) / sample_rate, unit='s')

            # we want to connect traces between touching activities
            if i < len(time_starts) - 1 and end == time_starts[i + 1]:
                # add the value at start of next segment to this segment
                next_mask = (t >= time_starts[i + 1]) & (t < time_ends[i + 1])
                next_trace_segment = raw_trace[next_mask]
                # append the first value of the next segment to the current segment
                trace_segment = np.append(trace_segment, next_trace_segment[0, 0, :][np.newaxis, :], axis=0)
                t_segment = t_segment.append(pd.DatetimeIndex([end]))

            for j in range(3):
                fig.add_trace(go.Scatter(x=t_segment, y=trace_segment[:, j], mode='lines',
                             name=str(activity),
                             line=dict(color=ACCELEROMETER_COLORS[j], width=1.0),
                             showlegend=False), row=index+1, col=1)

def add_legend(fig, labels, label_colors):
    """
    Adds a legend representing activities to a provided plotly figure.

    This function iterates over the provided labels, and for each label, 
    it adds a trace to the figure with the corresponding color.

    Args:
        fig (plotly.graph_objs._figure.Figure): The figure to which the legend will be added.
        labels (list or set): The labels to be included in the legend.
        label_colors (dict): A dictionary mapping labels to colors.
    """
    for activity in labels:
        color = f'rgba{COLORMAP(label_colors[activity])}'
        if color is not None:  # If color is found in the dictionary
            fig.add_trace(
                go.Scatter(x=[None], y=[None], mode='markers',
                            marker=dict(size=20, color=color, symbol='square'),
                            opacity=1.0,
                            showlegend=True,
                            name=activity),
                row=1, col=1
            )

def plot_compare(t, y_true, y_pred, window_size, label_colors, participant=None, trace=None, raw_traces=None, y_extents=None):
    """Graphically compares predicted with true labels overlaid with one accelerometer trace on an interactive plot.

    Args:
        t (array-like): Time values for the data.
        y_true (array-like): True labels corresponding to the time values.
        y_pred (array-like): Predicted labels corresponding to the time values.
        window_size (int): Window size in seconds.
        label_colors (dict): A dictionary mapping activity names to colors.
        participant (str, optional): The participant ID which is printed on the plot if not None. Defaults to None.
        trace (array-like, optional): Accelerometer traces values corresponding to the time values. The trace is
                                      normalised before plotting. Defaults to None.
        raw_traces (np.ndarray): 3D array of shape (n_windows, winsec*sample_rate, 3) containing the raw accelerometer data.
        y_extents (list, optional): The y-axis extents for the plots. Defaults to [0,1] via setting to None.
    
    Returns:
        plotly.graph_objects.Figure: The figure object so can be exported etc.
    """
    if y_extents is None:
        y_extents = [0,1]

    if trace is not None:  # normalize
        if isinstance(trace, (pd.DataFrame, pd.Series)):
            trace = trace.to_numpy()
        trace = (trace - np.min(trace)) / (np.max(trace)- np.min(trace))

    t = pd.to_datetime(t)

    fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.1)

    labels = [y_true, y_pred]

    for i, label in enumerate(labels):
        time_starts, time_ends, activity_array = find_consecutive_activities(t, label, window_size)
        add_shapes(fig, time_starts, time_ends, activity_array, label_colors, y_extents, i)
        if trace is not None:
            add_traces(fig, time_starts, time_ends, activity_array, trace, t, i)
        if raw_traces is not None:
            add_raw_traces(fig, time_starts, time_ends, activity_array, raw_traces, t, window_size, i)
        if trace is None and raw_traces is None:
            fig.add_trace(go.Scatter(x=[t[0], t[-1]], y=[None, None], showlegend=False), row=i+1, col=1) # dummy trace so can get x extents


    # Add a legend
    unique_labels = set(y_true.tolist()) | set(y_pred.tolist())
    add_legend(fig, unique_labels, label_colors)

    fig.update_yaxes(title_text='True', row=1, col=1)
    fig.update_yaxes(title_text='Pred', row=2, col=1)

    fig.update_layout(
        title_text=f'Participant {participant}' if participant is not None else None,  # Add title if participant is not None
        hovermode='closest',
        xaxis_showgrid=True,
        xaxis_gridcolor='black',
        xaxis_gridwidth=0.5,
        plot_bgcolor='#d3d3d3',
        paper_bgcolor='rgba(0,0,0,0)',
        xaxis=dict(range=[t[0], t[-1]],
                   tickmode='auto',
                   nticks=8,
                   gridcolor='white',
                   tickformat='%H:%M'),
        xaxis2=dict(range=[t[0], t[-1]],
                    tickmode='auto',
                    nticks=8,
                    #gridcolor='white',
                    tickformat='%H:%M:%S'),
        yaxis=dict(range=y_extents,
                   showline=False,
                   showticklabels=False,
                   fixedrange=True),
        yaxis2=dict(range=y_extents,
                    showline=False,
                    showticklabels=False,
                    fixedrange=True),
        margin=dict(l=0, r=0, t=30, b=0, pad=0),
        legend=dict(orientation='h',
                    xanchor='center',
                    x=0.5,
                    y=-0.15),
    )

    return fig

def plot_failure_cases(X, Y, Y_pred, time, label, sample_rate=30, swap_ground_and_predicted=False, n_samples=5):
    """Plots example accelerometer traces for each predicted label for a given ground truth label.

    Args:
        X (np.array): The windowed accelerometer data. Expected to have shape (n_windows, window_size, 3).
        Y (np.array): The ground truth labels for the data.
        Y_pred (np.array): The predicted labels for the data.
        time (np.array): The timestamps for the data.
        label (string): The label being analysed.
        sample_rate (int, optional): sample rate of data in Hz. Defaults to 30.
        swap_ground_and_predicted (bool, optional): If True, the ground truth and predicted labels are swapped. Defaults to False.
        n_samples (int, optional): The number of traces for each predicted label. Defaults to 5.
        
    Returns:
        plotly.graph_objects.Figure: The figure object so can be exported etc.
    """

    if swap_ground_and_predicted:
        Y, Y_pred = Y_pred, Y

    window_size = X.shape[1]

    labels = np.unique(Y_pred)
    num_labels = len(labels)
    plot_row_titles = labels.tolist()

    trace_names = ['mag', 'x', 'y', 'z']

    dummy_titles = [str(i) for i in range(0, n_samples * num_labels)]
    real_titles = []

    fig = make_subplots(
        rows=num_labels,
        cols=n_samples,
        horizontal_spacing=0.05/n_samples,
        vertical_spacing=0.25/num_labels,
        y_title=f'{"Ground truth" if swap_ground_and_predicted else "Predicted"} label',
        subplot_titles=dummy_titles,
        row_titles = plot_row_titles
    )

    legend_added = False # Only adding one subplot's legend as all subplots have same legend

    for i in range(num_labels):
        idxs = np.where((Y_pred==labels[i]) & (Y==label))[0]
        if len(idxs) < n_samples: # check to see if we have less examples for predicted label than n_samples
            actual_n_samples = len(idxs)
        else:
            actual_n_samples = n_samples
        idxs = np.sort(np.random.choice(idxs, size=actual_n_samples, replace=False))
        for j in range(n_samples):
            if j < actual_n_samples: # if j is within index boundary
                # Create a time range for the x-axis
                start_time = time[idxs[j]]
                end_time = start_time + pd.Timedelta(seconds=window_size/sample_rate)
                x_values = pd.date_range(start=start_time, end=end_time, periods=window_size)
                real_titles.append(f'Frame {idxs[j]}')
                y_values = [np.linalg.norm(X[idxs[j]], axis=1)-1, X[idxs[j], :, 0], X[idxs[j], :, 1], X[idxs[j], :, 2]]
                colors = ['black', 'red', 'green', 'blue']

            else: # if j is out of index boundary (no more examples for predicted label)
                # Create dummy times
                start_time = pd.Timestamp('2000-01-01 00:00:00')
                end_time = start_time + pd.Timedelta(seconds=window_size/sample_rate)
                x_values = pd.date_range(start=start_time, end=end_time, periods=window_size)
                real_titles.append(str(''))
                y_values = [[],[],[],[]] # empty plots
                colors = ['black', 'red', 'green', 'blue']

            show_legend = not legend_added and len(y_values[0]) > 0

            for k in range(4):
                fig.add_trace(go.Scatter(x=x_values,
                                         y=y_values[k],
                                        mode='lines',
                                        name=trace_names[k],
                                        showlegend=show_legend,
                                        line=dict(color=colors[k])),
                                    row=i+1, col=j+1)
            if show_legend:
                legend_added = True

    fig.update_layout(
        # height=num_labels * 150,
        # width=n_samples * 200,
        title={
            'text': f'Example plots for {"predicted" if swap_ground_and_predicted else "labelled"} {label} activity',
            'x':0.5,  # Halfway point makes the title centered
            'xanchor': 'center',
            'yanchor': 'top'
        },
        legend={
            'orientation': 'h', 
            'yanchor': 'bottom', 
            'y': 1.08, 
            'xanchor': 'right', 
            'x': 1
        }
    )

    # remove tick labels for all subplots and set axis extents
    fig.update_xaxes(showticklabels=False)
    fig.update_yaxes(showticklabels=False, range=[-2, 2])

    # set hovermode to x-combined
    fig.update_layout(hovermode='x unified')

    # hack to move row labels to the left as not currently option to plotly make_subplots
    fig.for_each_annotation(lambda a:  a.update(x = -0.025, textangle = -90) if a.text in plot_row_titles else())

    # hack to give each subplot its real title as titles are added at creation of subplots and don't know the title then
    title_map = dict(zip(dummy_titles, real_titles))
    fig.for_each_annotation(lambda a: a.update(text = title_map[a.text]) if a.text in title_map else())

    return fig
